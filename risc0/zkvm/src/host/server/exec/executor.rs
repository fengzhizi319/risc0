// Copyright 2024 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::{cell::RefCell, io::Write, rc::Rc, sync::Arc, time::Instant};

use anyhow::{Context as _, Result};
use risc0_binfmt::{MemoryImage, Program};
use risc0_circuit_rv32im::prove::emu::{
    addr::ByteAddr,
    exec::{
        Executor, Syscall as NewSyscall, SyscallContext as NewSyscallContext,
        DEFAULT_SEGMENT_LIMIT_PO2,
    },
};
use risc0_core::scope;
use risc0_zkp::core::digest::Digest;
use risc0_zkvm_platform::{fileno, memory::GUEST_MAX_MEM, PAGE_SIZE};
use tempfile::tempdir;

use crate::{
    host::client::env::SegmentPath, Assumptions, ExecutorEnv, FileSegmentRef, Output, Segment,
    SegmentRef, Session,
};

use super::{
    profiler::Profiler,
    syscall::{SyscallContext, SyscallTable},
};

// The Executor provides an implementation for the execution phase.
///ExecutorImpl 结构体是执行阶段的实现。它负责在证明阶段之前决定如何将 zkVM 程序分割成多个段（Segment），
/// 以及每个段中要完成的工作。这是执行阶段：执行来宾程序以确定其证明应如何划分为子部分
/// The proving phase uses an execution trace generated by the Executor.
pub struct ExecutorImpl<'a> {
    env: ExecutorEnv<'a>,
    image: MemoryImage,
    pub(crate) syscall_table: SyscallTable<'a>,//包含系统调用表。
    profiler: Option<Rc<RefCell<Profiler>>>,//可选的性能分析器，用于记录执行过程中的性能数据
}

impl<'a> ExecutorImpl<'a> {
    /// Construct a new [ExecutorImpl] from a [MemoryImage] and entry point.
    ///
    /// Before a guest program is proven, the [ExecutorImpl] is responsible for
    /// deciding where a zkVM program should be split into [Segment]s and what
    /// work will be done in each segment. This is the execution phase:
    /// the guest program is executed to determine how its proof should be
    /// divided into subparts.
    pub fn new(env: ExecutorEnv<'a>, image: MemoryImage) -> Result<Self> {
        Self::with_details(env, image, None)
    }

    /// Construct a new [ExecutorImpl] from the ELF binary of the guest program
    /// you want to run and an [ExecutorEnv] containing relevant
    /// environmental configuration details.
    ///
    /// # Example
    /// ```
    /// use risc0_zkvm::{ExecutorImpl, ExecutorEnv, Session};
    /// use risc0_zkvm_methods::{BENCH_ELF, bench::BenchmarkSpec};
    ///
    /// let env = ExecutorEnv::builder()
    ///     .write(&BenchmarkSpec::SimpleLoop { iters: 1 })
    ///     .unwrap()
    ///     .build()
    ///     .unwrap();
    /// let mut exec = ExecutorImpl::from_elf(env, BENCH_ELF).unwrap();
    /// ```
    pub fn from_elf(mut env: ExecutorEnv<'a>, elf: &[u8]) -> Result<Self> {
        // 从 ELF 二进制文件加载程序
        let program = Program::load_elf(elf, GUEST_MAX_MEM as u32)?;

        // 创建内存映像
        let image = MemoryImage::new(&program, PAGE_SIZE as u32)?;

        // 如果环境变量中包含 pprof 输出路径，则初始化 profiler
        let profiler = if env.pprof_out.is_some() {
            let profiler = Rc::new(RefCell::new(Profiler::new(elf, None)?));
            env.trace.push(profiler.clone());
            Some(profiler)
        } else {
            None
        };

        // 使用详细信息初始化 ExecutorImpl
        Self::with_details(env, image, profiler)
    }

    fn with_details(
        env: ExecutorEnv<'a>,
        image: MemoryImage,
        profiler: Option<Rc<RefCell<Profiler>>>,
    ) -> Result<Self> {
        let syscall_table = SyscallTable::from_env(&env);
        Ok(Self {
            env,
            image,
            syscall_table,
            profiler,
        })
    }

    /// This will run the executor to get a [Session] which contain the results
    /// of the execution.
    pub fn run(&mut self) -> Result<Session> {
        // 如果 segment_path 为空，则创建一个临时目录
        if self.env.segment_path.is_none() {
            self.env.segment_path = Some(SegmentPath::TempDir(Arc::new(tempdir()?)));
        }

        // 获取 segment_path
        let path = self.env.segment_path.clone().unwrap();

        // 运行带有回调的执行器
        self.run_with_callback(|segment| Ok(Box::new(FileSegmentRef::new(&segment, &path)?)))
    }


    /// Run the executor until [crate::ExitCode::Halted] or
    /// [crate::ExitCode::Paused] is reached, producing a [Session] as a result.
    pub fn run_with_callback<F>(&mut self, mut callback: F) -> Result<Session>
    where
        F: FnMut(Segment) -> Result<Box<dyn SegmentRef>>,
    {
        // Start a new scope for tracing execution
        scope!("execute");

        // Initialize a journal to capture output
        let journal = Journal::default();
        self.env
            .posix_io
            .borrow_mut()
            .with_write_fd(fileno::JOURNAL, journal.clone());

        // Determine the segment limit, defaulting to a predefined value if not set
        let segment_limit_po2 = self
            .env
            .segment_limit_po2
            .unwrap_or(DEFAULT_SEGMENT_LIMIT_PO2 as u32) as usize;

        // Vector to store references to segments
        let mut refs = Vec::new();
        // Create a new executor instance
        let mut exec = Executor::new(
            self.image.clone(),
            self,
            self.env.input_digest,
            self.env.trace.clone(),
        );

        // Record the start time for execution
        let start_time = Instant::now();
        // Run the executor with the specified segment limit and session limit
        let result = exec.run(segment_limit_po2, self.env.session_limit, |inner| {
            // 检查退出代码是否需要输出
            let output = inner
                .exit_code
                .expects_output() // 如果退出代码需要输出
                .then(|| -> Option<Result<_>> {
                    // 如果需要输出，捕获日志缓冲区
                    inner
                        .output_digest // 获取输出摘要
                        .and_then(|digest| {
                            (digest != Digest::ZERO).then(|| journal.buf.borrow().clone()) // 如果摘要不为零，克隆日志缓冲区
                        })
                        .map(|journal| {
                            Ok(Output {
                                journal: journal.into(), // 将日志缓冲区转换为输出
                                assumptions: Assumptions(
                                    self.syscall_table
                                        .assumptions_used // 获取使用的假设
                                        .borrow()
                                        .iter()
                                        .map(|(a, _)| a.clone().into()) // 克隆并转换假设
                                        .collect::<Vec<_>>(),
                                )
                                    .into(),
                            })
                        })
                })
                .flatten()
                .transpose()?; // 展平并转换结果

            // 创建一个包含捕获输出的新段
            let segment = Segment {
                index: inner.index as u32, // 段的索引
                inner, // 内部段数据
                output, // 段的输出
            };
            println!("segment: {:?}", segment);
            // 使用回调函数处理段并存储引用
            let segment_ref = callback(segment)?; // 调用回调函数处理新创建的段，并获取处理后的段引用
            refs.push(segment_ref); // 将处理后的段引用存储在 refs 向量中
            Ok(())
        })?;
        //println!("refs: {:?}", refs);
        // Calculate the elapsed time for execution
        let elapsed = start_time.elapsed();

        // Set the session journal to the committed data if the guest set a non-zero output
        let session_journal = result
            .output_digest
            .and_then(|digest| (digest != Digest::ZERO).then(|| journal.buf.take()));
        if !result.exit_code.expects_output() && session_journal.is_some() {
            tracing::debug!(
            "dropping non-empty journal due to exit code {:?}: 0x{}",
            result.exit_code,
            hex::encode(journal.buf.borrow().as_slice())
        );
        };

        // Clear the list of accessed assumptions, but keep the cache for potential resumption
        //清空并获取 syscall_table 中 assumptions_used 字段的值。具体来
        let assumptions = self.syscall_table.assumptions_used.take();
        // Clear the list of pending zkrs, but keep the cache for potential resumption
        let pending_zkrs = self.syscall_table.pending_zkrs.take();

        // If a profiler is present, finalize and write the report
        if let Some(profiler) = self.profiler.take() {
            let report = profiler.borrow_mut().finalize_to_vec();
            std::fs::write(self.env.pprof_out.as_ref().unwrap(), report)?;
        }

        // Update the memory image with the post-execution state
        self.image = result.post_image.clone();

        // Create a new session with the collected data and execution results
        let session = Session::new(
            refs,
            self.env.input_digest.unwrap_or_default(),
            session_journal,
            result.exit_code,
            result.post_image,
            assumptions,
            result.user_cycles,
            result.paging_cycles,
            result.reserved_cycles,
            result.total_cycles,
            result.pre_state,
            result.post_state,
            pending_zkrs,
        );

        // Log the execution time
        tracing::info!("execution time: {elapsed:?}");
        session.log();

        // Return the created session
        Ok(session)
    }
}

struct ContextAdapter<'a, 'b> {
    ctx: &'b mut dyn NewSyscallContext,
    syscall_table: SyscallTable<'a>,
}

impl<'a, 'b> SyscallContext<'a> for ContextAdapter<'a, 'b> {
    fn get_pc(&self) -> u32 {
        self.ctx.get_pc()
    }

    fn get_cycle(&self) -> u64 {
        self.ctx.get_cycle()
    }

    fn load_register(&mut self, idx: usize) -> u32 {
        self.ctx.peek_register(idx).unwrap()
    }

    fn load_page(&mut self, page_idx: u32) -> Result<Vec<u8>> {
        self.ctx.peek_page(page_idx)
    }

    fn load_u8(&mut self, addr: ByteAddr) -> Result<u8> {
        self.ctx.peek_u8(addr)
    }

    fn load_u32(&mut self, addr: ByteAddr) -> Result<u32> {
        self.ctx.peek_u32(addr)
    }

    fn syscall_table(&self) -> &SyscallTable<'a> {
        &self.syscall_table
    }
}

impl<'a> NewSyscall for ExecutorImpl<'a> {
    fn syscall(
        &self,
        syscall: &str,
        ctx: &mut dyn NewSyscallContext,
        into_guest: &mut [u32],
    ) -> Result<(u32, u32)> {
        let mut ctx = ContextAdapter {
            ctx,
            syscall_table: self.syscall_table.clone(),
        };
        self.syscall_table
            .get_syscall(syscall)
            .context(format!("Unknown syscall: {syscall:?}"))?
            .borrow_mut()
            .syscall(syscall, &mut ctx, into_guest)
    }
}
/*
Journal 结构体的主要功能是捕获执行过程中产生的日志输出，并将其存储在一个可访问的缓冲区中。它实现了 Write trait，因此可以像标准输出流一样使用。具体功能包括：
缓冲区：使用 Rc<RefCell<Vec<u8>>> 来存储日志数据，以便在多个地方共享和修改。
写入日志：实现 write 方法，将日志数据写入缓冲区。
刷新日志：实现 flush 方法，刷新缓冲区中的日志数据。
这些功能使得 Journal 可以在执行过程中捕获和存储日志输出，方便后续访问和处理。
 */
// Capture the journal output in a buffer that we can access afterwards.
#[derive(Clone, Default)]
struct Journal {
    buf: Rc<RefCell<Vec<u8>>>,
}

impl Write for Journal {
    fn write(&mut self, bytes: &[u8]) -> std::io::Result<usize> {
        self.buf.borrow_mut().write(bytes)
    }

    fn flush(&mut self) -> std::io::Result<()> {
        self.buf.borrow_mut().flush()
    }
}
